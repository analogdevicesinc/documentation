.. _adsp setup:

Getting started
===============

ADSP evaluation boards do not ship with pre-installed software. The chips also
do not support booting directly from SD cards. Therefore the evaluation boards
need to be bootstrapped over JTAG using a :adi:`ADI ICE-1000 or ICE-2000 JTAG
debugger <en/resources/evaluation-hardware-and-software/evaluation-boards-kits/emulators.html>`.

JTAG & OpenOCD Setup
-----------------------------

To communicate with the board, you must build and run the ADI fork of OpenOCD.

Install Dependencies
~~~~~~~~~~~~~~~~~~~~

**Ubuntu**

.. shell:: sh

   $sudo apt install -y git autoconf automake libtool pkg-config \
   $libjim-dev gcc g++ make texinfo gdb-multiarch

**Fedora**

.. shell:: sh

   $sudo dnf install git autoconf automake libtool pkgconfig \
   $jimtcl-devel gcc gcc-c++ make texinfo gdb

**Windows (MSYS2)**

Open a **MinGW64** shell and run:

.. shell:: sh

   $pacman -Syu
   $pacman -S --needed git mingw-w64-x86_64-toolchain \
   $mingw-w64-x86_64-libusb mingw-w64-x86_64-hidapi \
   $mingw-w64-x86_64-libtool mingw-w64-x86_64-pkg-config \
   $mingw-w64-x86_64-jimtcl autoconf automake make

Build OpenOCD
~~~~~~~~~~~~~

.. shell:: sh

    $git clone https://github.com/analogdevicesinc/openocd
   $cd openocd
   $./bootstrap
   $./configure
   $make -j$(nproc)

*Note: On Windows, the resulting ``openocd.exe`` can be run directly.*

Run OpenOCD
~~~~~~~~~~~

Run ``openocd`` from the cloned repository. For the ICE-1000 and EV-SC598-SOM run the following:

.. shell:: sh

    # Ensure you are inside the 'openocd' folder
    ~/openocd
    $sudo src/openocd -f ice1000.cfg \
    $    -f adspsc59x_a55.cfg \
    $    --search tcl/ \
    $    --search tcl/interface/ \
    $    --search tcl/target/

* Target (Cortex-A5): Use ``adspsc59x.cfg`` (e.g., SC594).
* Target (Cortex-A55): Use ``adspsc59x_a55.cfg`` (e.g., SC598).

*Note: The ``*_single_SHARC.cfg`` variants are for devices with only one SHARC core enabled (e.g., SC592).*

Serial Console Setup
-----------------------------

A serial console is highly recommended for interacting with U-Boot and Linux.

1. Connect a standard USB cable from your PC to the board's UART/Debug port.
2. Identify the port

   * **Linux:** Check the ``by-id`` directory to find your unique device name.

   .. shell:: sh

      $ ls /dev/serial/by-id/

   On SC5xx systems, the console appears as a CP2102N USB-to-UART bridge with a unique serial number, for example:

      .. shell:: sh

         $ tree /dev/serial/by-id
         /dev/serial/by-id
         ├── usb-Silicon_Labs_CP2102N_USB_to_UART_Bridge_Controller_1e574c842d61ed1193564f8009472825-if00-port0 -> ../../ttyUSB1
         └── usb-Silicon_Labs_CP2102N_USB_to_UART_Bridge_Controller_8624ff6b1261ed11a8d3518009472825-if00-port0 -> ../../ttyUSB0

   This naming is stable because the USB-UART bridge provides a unique serial number.

   * **Windows:** Open Device Manager > Ports (COM & LPT). The SC5xx console appears as a Silicon Labs CP210x USB to UART Bridge with an assigned port such as COM3 or COM7. The COM number is stable as long as the adapter remains on the same USB port.

3. Configure your terminal
   Configure the serial terminal for 115200 baud, 8 data bits, no parity, 1 stop bit (8-N-1), and disable all flow control.

   Example with Minicom(Linux):

   .. shell:: sh

      # Replace with your specific device path found above
      $sudo minicom -D /dev/serial/by-id/<your-device-name> -b 115200

Booting the System
---------------------------

Download Release
~~~~~~~~~~~~~~~~~~

Navigate to the :git-br2-external:`br2-external releases page <releases+>` and
download the appropriate ``images-*.tar.xz`` release archive that matches your 
hardware.

Boot U-Boot Proper
~~~~~~~~~~~~~~~~~~

.. warning::
   **Check Boot Mode Switch (S1)**

   Before powering on, locate the rotary switch labeled "S1 (Boot Mode Select)" on the board.
   Ensure the arrow on the dial is pointing to position "0".

You need a multi-architecture GDB to load the bootloader.

1.  **Install GDB:**

   * Ubuntu/Debian: ``sudo apt-get install -y gdb-multiarch``
   * Windows: ``pacman -S mingw-w64-x86_64-gdb``
   * Fedora/RHEL: ``sudo dnf install -y gdb``

2.  **Download Helper Script:**

    .. shell:: sh

        $curl -O https://raw.githubusercontent.com/analogdevicesinc/documentation/refs/heads/main/docs/products/adsp/u-boot.gdb

3.  **Run GDB:**

    .. shell:: sh

       # Ubuntu/Debian
       $gdb-multiarch -x u-boot.gdb

       # Fedora/RHEL/Windows
       $gdb -x u-boot.gdb
   
   *Note: The ``u-boot.gdb`` script expects the bootloader binaries to be present in the current directory with their default names (``u-boot-spl`` and ``u-boot``).*

Boot Linux
~~~~~~~~~~

1.  **Start File Server:**
    Open a *new* terminal on your PC, go to your release directory, and run:

    .. shell:: sh

        $python3 -m http.server

2.  **Find your PC IP Address:**

    * Linux: Run ``ip a``
    * Windows: Run ``ipconfig``

3.  **Boot from U-Boot:**
    In the serial console, run the following (replace ``<your-pc-ip>`` with the IP you found above):

    .. code-block:: console

        => dhcp
        => wget ${kernel_addr_r} <your-pc-ip>:/Image
        => wget ${fdt_addr_r} <your-pc-ip>:/sc598-som-ezkit.dtb
        => booti ${kernel_addr_r} - ${fdt_addr_r}

   *Note: Make sure to use the ``.dtb`` file name that matches your board (e.g., ``sc598-som-ezkit.dtb``).*